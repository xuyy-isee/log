2017.09.04(一)
从今天开始，修改网络拓扑结构，重新测试在不同的网络拓扑结构下，之前对OLSR路由协议的优化是否还能奏效。

log170904_1中存放的是网络中节点全连通的状态，即任何一个节点都是本节点的一跳邻居节点；
log170904_2里面是平时仿真时候所使用的拓扑结构；
log170904_3中存放的是netform.h文档中原先注释掉的拓扑结构；
log170904_4_1中存放的是UCDS所在文献中实验部分的第一个例子所用的拓扑结构图(错误)；
log170904_4_2中存放的是UCDS所在文献中实验部分的第一个例子所用的拓扑结构图(正确)；




2017.09.05(二)
log170904_4_1中的仿真是存在问题的，如下所示。
节点13和节点12根本就不相连的，但是节点13和节点6是相连的，因为这样的错误使得节点13没有成为骨干节点。
  cdset_node_id = [6] .
  cdset_node_id = [11] .
  cdset_node_id = [12] .
  
  main_node_id = [13], main_node_nbnum = 2 

  main_node_id = [13], nb_node_id = [11], nb_status = 1 .  
  main_node_id = [13], nb_node_id = [14], nb_status = 1 .  
  main_node_id = [13], nb_node_id = [6], nb_status = 0 .  
  main_node_id = [13], nb_node_id = [12], nb_status = 0 .  

后来重新运行之后即为正确，正确的运行结果存放在log170904_4_2。
  cdset_node_id = [6] .
  cdset_node_id = [11] .
  cdset_node_id = [13] .
  
  main_node_id = [13], main_node_nbnum = 3 

  main_node_id = [13], nb_node_id = [11], nb_status = 1 .  
  main_node_id = [13], nb_node_id = [6], nb_status = 1 .  
  main_node_id = [13], nb_node_id = [14], nb_status = 1 .  
 
通过查看9.4文件中的4个拓扑结构仿真下得到的结果，可以知道这种从骨干节点中选择MPR节点的方法是没有问题的，但是当使用UCDS所在文献中实验部分的第二个例子所用的拓扑结构图经过简化的拓扑结构的时候，发现了该方案不能找到MPR节点的重大问题！！！
继续细读《基于WNW战术波形网络的拓扑控制及路由优化研究》！！！！


虚拟骨干节点是由DS节点和CS节点共同组成的，再选虚拟骨干网络的时候要把整个流程都走一
遍。
Stage1: 每个节点执行DS规则，即指定自身或邻居节点为DS成员，得到DS集和非DS集；
Stage2: 非DS成员节点执行非CS规则，从非DS集中除去非CS节点；
Stage3: 对非DS集合中节点i执行简单CS例外及CS规则，得到必须为CS成员的节点，并将其从非DS集合中去除，加入CS集合，即：
	step1: 对节点i遍历其邻居j、k，若只有一个为DS成员，执行step2；否则，执行step3；
	step2: 执行CS例外规则第二条，若CS例外规则成立，跳转step1；否则，跳转step3；
	step3: 若j、k不直连且不存在公共邻居(非i)，此时i必须为CS成员，将其从非DS集中去除，加入到CS集合，遍历结束；
Stage4: 对非DS集合节点i执行CS例外及CS规则，可得CS集合，即：
	step1: 对节点i遍历其邻居j、k，若j、k中至少一个为DS节点，跳转step2；否则继续遍历；
	step2: 执行CS规则，成立则跳转step1，失败则跳转step3；
	step3: 执行CS规则，若i为CS节点，加入CS集，结束遍历；否则跳转step1。

对于标记二跳节点是否为DS节点可以使用nbset，这个在CS例外规则里面要用到；
--------------------好像也不用，因为这个两条节点就是本节点的一跳邻居节点
对于标记CS节点，可以将信息存放在本节点的link code的4bit中的1bit，因为每个节点只要判断自己是不是CS节点；
对于标记CS'节点，也可以只用4bit中的1bit；

估计这一块的代码要写一段时间的，争取两天之内调出来。







2017.09.06(三)
unifying connected domainting set with low message complexity, fault tolerance, and flexible dominating factor.

unifying connected domainting set using localized two hop informating with a flexible dominating factor.

simple and efficient backbone algorithm for calculating connected dominating set in wireless Ad-hoc network.

今天只写了step2、step3，明天可以开始写step4。






2017.09.07(四)
今天开例会的时候，雷老师提醒了我一个很重要的问题，这个问题也是我之前一直忽略没有考虑的——————比特数是否够用？

因为既然文献中已经写出来了，那么就肯定是能够实现的，所以我就一直在写代码。然而我忽略了一个很重要的区别，就是HELLO消息的比特数是否够用。因为我们工程中使用的HELLO消息是128bit的，而目前仅剩的空闲比特数也很少了，所以这是一个基于所有问题之前的重大考虑！
在UCDS-MPR算法中，由于在选择CS节点的中间有中间过度节点的出现，即CS'的存在，在CS规则中，它表示“若节点j和k的共同邻居节点中存在多个CS'，则具有最高支配因子的CS'成员将被选为CS成员”。这里面选择自己是否为CS不是自己能够决定的，需要查看二跳节点的支配因子，而这点我们是不知道的。
在CS例外规则中，它表示“对于非DS成员节点i，当邻居节点j和k的共同邻居中有一个CS成员，此时CS规则不用执行”。由于于本节点都接收不到二跳节点的HELLO消息，根本就不能知道二跳节点是否为CS节点，因此该条规则是无法执行的。

以上所说的无法执行，是在执行DS规则时候确定的方案下没有足够的HELLO消息比特数来支持上面的节点信息进行交互。


【ATTENTION】
每次都有这个问题！！！
方案没有确定就开始写代码，写出来的代码大部分易做无效处理！！那么这就是浪费时间做无用功！！






2017.09.08(五)

---------------------------------【大问题】----------------------------------------
昨天对UCDS-MPR选择算法的流程初步估计HELLO消息比特数是不够用的，下面就来具体的分析一下。
导致比特数不够用最主要的部分就是CS规则。
CS规则：对于非DS成员节点i，存在邻居节点j和k，其中两者至少有一个为DS成员，且两者DS邻居节点集不相交，则节点i为CS的候选成员CS'；若节点j和k的共同邻居节点中存在多个CS'，则具有最高支配因子的CS'成员将被选为CS成员。
按照原先的想法，如果本节点通过CS规则评估自己为CS'，那么本节点在HELLO消息自己节点号所对应的Link Code的那4bit中的1bit进行标记，说明自己是CS'；
当邻居节点接收到本节点的HELLO消息，并知道本节点为CS'，他们将该信息记录下来，并存放在每个节点自己维护的CS'表中；
在邻居节点中选择一个节点作为本节点，它查看自己和某一个邻居节点的共同邻居中是否存在多个CS'，如果存在，那么就选择其中支配因子最大的一个节点作为CS节点；
本节点要将自己选择了哪个节点为CS节点的信息通过HELLO消息告诉该邻居节点，那怎么告诉呢？
1) 专门用5bit来表示节点号？---那么比特数肯定是不够用的！
2) 借用Link Code中2bit的第四种表达方式？---这种方法在选用DS节点的时候就已经被否定了！
---------------------------------【大转折】----------------------------------------
这个方法好像还可以再考虑一下！！因为现在的情况和DS节点当时的情况有所不同，现在我们可以借用DS的消息来进行区分。
在Link Code中，我们无非就是要区分两种情况，一种是没有被选为MPR节点的CS节点，另一种是被选为MPR节点的CS节点；
我们可以用MPR_NEIGH表示被选为MPR的CS节点，用CS_NEIGH表示没有被选为MPR的Cs节点；
虽然HELLO消息中可能有很多节点都会被标记成MPR_NEIGH，但是当接收到的节点排除自己是DS节点之后就可以知道自己是作为CS节点被选为MPR节点的；
排除的方法有多种：
1) 如果该节点之前没有任何DS节点的标志，本节点选择该节点为DS节点，那么在choose_cd_node_id()这个标志位上会标识出来。当该节点对应节点号的Link Code是MPR_NEIGH，且choose_cd_node_id()为该节点节点号，那么该节点是先被本节点选为DS节点，然后再被选为MPR节点了；
2) 如果该节点之前就有DS节点的标志，那么即使本节点发送的HELLO消息对应节点号的Link Code是MPR_NEIGH，而choose_cd_node_id()不是该节点节点号，也不会说明该节点是CS节点的，因为CS节点是在非DS节点中选取的，那么该节点是作为DS节点的身份被选为MPR节点的；
3) 如果该节点之前没有任何DS节点的标志，本节点发送的HELLO消息对应节点号的Link Code是MPR_NEIGH，而choose_cd_node_id()不是该节点节点号，那说明该节点是CS节点的，因为本节点只会在DS、CS节点中选取MPR节点，既然本节点没有选择该节点作为DS节点，且该节点也没有其他的DS节点标志，但本节点选择该节点作为MPR节点，那么就可以说明该节点是先被本节点选为CS节点，然后以CS节点的身份被选为MPR节点的；
4) 如果该节点之前没有任何DS节点的标志，本节点发送的HELLO消息对应节点号的Link Code是CS_NEIGH，而choose_cd_node_id()不是该节点节点号，那也会说明该节点是CS节点的，该节点被本节点选为CS节点，但没有被选为MPR节点。






















