2017.08.22(二)

雷老师之前给了一篇论文让我消化，这是现在美军正在采用的优化路由的方法，主要是看看它所使用的方法是否能够用在我们的路由上，并有一定的优化作用。————《基于WNW战术波形网络的拓扑控制及路由优化研究》

现在将其中的UCDS-MPR选择算法应用在本项目中，从而达到优化MPR集合的目的。
算法的具体过程如下：
R(x)表示节点x的到达性，即去除MPR集中的节点以及被其覆盖的二跳节点后，N中某节点的邻居节点数量，不包括N及本节点；
D(x)表示节点x的深度，即节点x的邻居数量，不包括N及本节点；

第一步,构建好本节点的N集合,依据UCDS协议的执行结果,从N集合中删除非虚拟骨干节点,根据N集合构建N2集合。
第二步,计算N集合中所有邻居节点深度D(x)。
第三步,如果N2集合中的某一邻居节点与本节点通过N集合中的唯一节点x进行通信,将x加入MPR集,并从N2中删除x节点覆盖的所有二跳邻居。当N2集合为空时,则算法结束。否则,执行第四步。
第四步,计算N集合中所有邻居节点的到达性,删除具有最小到达性的邻居节点。如果有多个,可依据UCDS协议中计算的节点支配因素信息,删除支配因素较小的一个节点,返回第三步继续执行。删除具有最小到达性的邻居节点,表明该节点不可能再加入MPR集。



DS规则:拓扑图G中某一节点i在其所有邻居节点j中具有最高支配因子di,则节点i指定自身为DS成员;也有可能是节点i在其邻居节点j的所有邻居k中具有最高支配因子di,则节点j指定节点i为DS成员。

关于如何统计节点的邻居节点数量，从而推选出虚拟骨干接点，有一下两个考虑：
(1) 本节点统计其本身的邻居节点个数，可以查看一跳邻居节点的总数；
(2) 本节点统计其一跳节点的邻居个数，可以查看通过其中某一个一跳节点到达二跳节点的链路的个数，其中包括通过二跳节点是一跳节点集中的链路，最后将总数+1即可得到其一跳节点的邻居个数。

由于在MPR推选的时候只需要推选出N中的虚拟骨干接点，所以只需要用到上面的(2)就可以了。



现在思考一个问题，在推选算法的“第一步”中写道“依据UCDS协议的执行结果,从N集合中删除非虚拟骨干节点”，这里的“骨干节点”应该是以整个网络为背景推选出来的骨干节点，还是每个本节点及其一跳邻居节点、二跳邻居节点组成的小网络的推选出来的归属于自己小网络的骨干节点？？
在写代码之前还要好好考虑，注意怎么修改！！！！！

【猜想一】在“第一步”里面有是说“构建好本节点的N集合,依据UCDS协议的执行结果,从N集合中删除非虚拟骨干节点”，即先构建好N集合，再执行UCDS协议，这样的前后关系是不是说明它是小网络的执行？

【猜想二】在文献中4.2.2开始部分提到“节点从其属于虚拟骨干网的一跳邻居节点集中选择本节点的MPR集,该MPR集定会保证本节点与其所有的二跳邻居节点进行互相通信”，即先找到虚拟骨干节点，再寻找MPR节点，这样的前后关系是不是说明UCDS是在整个网络环境下执行的？

【结论】在文献的第33页提到“UCDS—MPR选择算法是在UCDS协议产生的虚拟骨干网中执行MPR选择,而虚拟骨干网是整个网络拓扑的一个子集,理论上UCDS—MPR选择算法选择出的MPR集冗余度相对标准MPR选择算法低”，因此，【猜想二】是正确的。



修改的代码放在OLSR_change3_1.cc中，主要增加了void OLSR::UCDS_CD_computation()和void OLSR::UCDS_mpr_computation()这两个函数；前者是统计内个节点的邻居节点数量，并选择骨干接点，将两者第存放在linkset里面；后者是利用前者的标识和数据来计算MPR节点，来编写UCDS-MPR选择算法流程。







2017.08.23(三)
今天修改的最终代码在OLSR_change3_2.cc中，最后一次运行正常的日志放在log170823_3中，还没有仔细看是否存在问题，明天细看。






2017.08.24(四)

log170824_1：这里是存在问题的，被选为CD节点的有：1\9\10\11\12\13\14\15\19
除了节点19不能解释，其他都可以。

log170824_2：这里邻居节点的数量都是25、80+、161等很大的数值，明显是错误的。
而且所有的邻居节点他们的邻居数量都是一致的，在统计上是有问题。

后来发现是assert()这个函数没有起到相应的功能。

log170824_3：修改之后打印出来的结果是正确的，此时MPR节点为：1\9\10\11\12\13\14，这些节点不会随着不同的打印而发生变化，因为在相同邻居节点数量的时候会选择节点号更加大的节点作为CD节点。
相比于之前标准算法选出来的MPR节点，UCDS-MPR算法有两个优势，首先节点的数量更少，原先算法的MPR节点数量是9，现在是7；其次MPR节点不会发生变化，由于原先算法当二条邻居节点被两个一跳邻居节点同时覆盖的时候是随机选择其中一个作为MPR节点的，所有每次的MPR都会有一定的变化；而新算法则不同，它会在支配银子相同的时候选择节点号更大的节点作为MPR节点。


log170824_4：每个节点网中只会推选出一个CD节点，即每个小网络中最多只会有一个MPR节点，有的甚至没有，这是因为在该小网络中本节点推选了自己作为CD节点。
现在的设定的是每个HELLO消息来了都会更新link信息，接着更新UCDS_CD_computation()函数，即都会重新结算CD节点；更新之后再重新计算mpr节点，UCDS_mpr_computation()最多只有一个MPR节点，是不正确的;这样的话会影响拓扑表的建立，从而影响路由表的建立，从本log中可以看出节点7一直都没有" h=3."部分的路由。

现在的考虑是是不是要把通过HELLO消息更新的UCDS_CD_computation()函数，以及其中的CD节点信息通过TC消息广播出去给所有的节点？

可以考虑通过TC消息将CD节点的信息广播出去，然后每个节点都建立一个骨干节点表，类似于拓扑表一样的存在，但是更加简单；而且只有骨干接点才会有发送和转发，且发送频率更低。

不过距离更远的节点根本没有用到本节点的骨干接点，只有相邻的节点才用的，这里可以考虑用HELLO消息来更新，不过这样泛洪很厉害。


可以参考原先的MPR节点是怎么处理的。

现在的代码存放在OLSR_change3_3.cc中。





拓扑变化主要用于判断两跳邻居拓扑结构是否发生变化,以及本节点和两跳邻居节点的支配因素是否发生变化。网络中每个节点执行UCDS算法的前提条件是本节点的两跳邻居拓扑结构发生变化或者两跳邻居节点的支配因素发生变化,即当节点的网络拓扑变化时,节点才会执行UCDS算法,当节点的网络拓扑稳定时,不进行UCDS算法计算,降低网络消耗。


【解决方案】

参考原先的MPR节点是怎么处理的。

(1)MPR节点信息会以neighbor_type的形式存放在HELLO消息包中发送给本节点的邻居节点，虽然我也可以增加一个OLSR_CD_BEIGH的neighbor_type，但是这样也只有邻居节点才会知道，连二跳节点都不会知道了；而且当节点选了自己作为CD节点的时候就不能存放在HELLO消息中了。

(2)如果像MPR那样，用TC消息的方式广播出去，那么就需要在修改TC消息格式，在其中占用20个bit了，这样的修改成本太高了。

(3)原论文中是怎么考虑的？
EB—OLSR协议最终通过WNW波形的跨层信令从链路层获取邻居信息及虚拟骨干网信息,进行MPR选择。（？？？？）

(4)事实上，每个节点只要知道邻居节点是不是CD节点就好了，还是存在问题。


【总结】一下现在存在的问题：不管用HELLO消息传达骨干节点的信息还是同TC消息广播骨干节点的信息都存在一定的问题。
(1)HELLO消息：当自己是骨干节点的时候，可以通过HELLO消息告诉所有的邻居节点自己是骨干信息，只要在HELLO消息中使用一个bit来记录即可，每个邻居节点都在自己的骨干节点表上记录下该节点的信息；
当本节点推选自己的邻居节点为骨干节点时，可以将neighbor_type记录为OLSR_CD_BEIGH，这里不需要占用bit，当这个节点接收到该HELLO消息，先在自己的骨干节点表上记录下自己的信息，然后再把自己是骨干节点的信息通过HELLO消息告诉自己的邻居节点。
(2)TC消息
TC消息是通过MPR节点产生并转发的，骨干节点要借助TC消息广播则首先要产生MPR节点，但是
MPR节点又是从骨干节点中选出来的。两者都需要前者先知道，因此矛盾，该方法无效。



log170824_5：将MPR节点打印出来。



最后采用了上面的(1)方式进行解决，但是代码运行有问题，明天开始调试。






2017.08.25(五)

log170825_1：完全有问题，到处都是问题。
现在关注一点：为什么每个节点的邻居数量统计是有问题的？由于邻居信息是由HELLO消息更新的，所有这和HELLO消息有关？昨天的修改方案也确实只涉及了HELLO消息。


【思考】刚刚在例会的时候想到一个问题，我现在使用HELLO消息告诉邻居节点的方式是不是有点冗余，事实上只要这样就可以了：
(1) 如果本节点被邻居节点推选为骨干节点，则它通过HELLO消息中的msg.hello_msg.cd_node()这个标志位标志自己为骨干节点，接收到该HELLO消息的邻居节点就将该节点加入自己的骨干接点表中；
(2) 如果本节点推选其邻居节点为骨干节点，则它通过将该节点的neighbor_type标志为OLSR_CD_NEIGH的方式标识该节点，当接收到HELLO消息的节点不是该节点时，则不处理；当接收到
HELLO消息的节点就是该节点时，则它记录自己被选为骨干接点，然后再标识自己的HELLO消息中的msg.hello_msg.cd_node()标志位，最后广播给自己的邻居节点，过程如(1)。


【问题】现在的代码都没有涉及到有骨干节点离开网络了，或者链路断开了，如何将该骨干节点从所有节点的骨干节点表中删除。这个要好好思考。

log170825_2：

函数UCDS_CD_computation()

if(mine_cd == true ){
// && link_tuple->local_main_node_nbnum() > 0  ){



log170825_3：
函数UCDS_CD_computation()

if(mine_cd == true && link_tuple->local_main_node_nbnum() > 0  ){



函数link_sensing()

if ((lt == OLSR_SYM_LINK && nt == OLSR_NOT_NEIGH) ||//链路对称，但没有对称邻居
//if ( lt == OLSR_UNSPEC_LINK || nt == OLSR_NOT_NEIGH ||
( nt != OLSR_NOT_NEIGH && nt != OLSR_SYM_NEIGH && nt != OLSR_MPR_NEIGH &&  nt != OLSR_CD_NEIGH )){//Neighbor Type不是三种类型之一
	fprintf (stdout, "  Can not come in. \n");
	continue;
}


log170825_4：

第3729行：if (nt == OLSR_SYM_NEIGH || nt == OLSR_MPR_NEIGH ){//|| nt == OLSR_CD_NEIGH) {






2017.08.26(六)

【另外】每个节点到底是不是维护各自的骨干接点表啊，还是所有的骨干节点表都在同一张表格中？————————不过好像都没有关系。


先不说别的（比如代码书写上是不是有问题），之前的整个思路就是存在问题的！
每个节点应该把自己所知道的骨干接点都通过HELLO消息广播给邻居节点，不管自己是被别的节点选为骨干接点的，还是自己推选自己为骨干接点的，亦或者自己推选了别的节点等等，只要是在自己的骨干节点表中的，都应该使用msg.hello_msg.cd_node()以及OLSR_CD_NEIGH这两个进行标记。


【问题】可是如果该节点之前推选的是其中一个节点作为骨干节点，之后更新了邻居之后又推选了另一个节点作为骨干节点，那怎么在节点表中去除之前不对的那个骨干节点啊？？？
eg.(1)假设节点1在邻居节点的支配因子都为1的情况下选择了节点19作为它的骨干节点，然后节点19接收到节点1的HELLO消息中的OLSR_CD_NEIGH标志位说自己被选为骨干节点了，它就自己通过HELLO消息中的msg.hello_msg.cd_node()标志位告诉自己的邻居节点说自己是骨干节点了。
(2)但是之后更新了支配因子，节点1又推选自己为骨干节点了，但是在它本身的骨干节点表中节点19是不能除去的，因为它不知道节点19是自己选它做骨干节点的，还是别的节点选它做骨干节点，然后节点19通过HELLO消息告诉节点1的，因此无法删除骨干节点表中的节点19，也不能删除节点19通过HELLO广播给它的邻居节点的骨干接点表中的节点19。


【致命问题】
现在的问题是不知道怎么更新和维护骨干节点表！！！！
需要和雷老师好好讨论！！


【分析】这个和MPR节点不一样，因为MPR节点是每次HELLO消息来了都会更新的，不是更新，都会重建的，结束了就会清零的，但是骨干节点是整个网络的，肯定不行。
这个和拓扑表能一样吗？拓扑表的维护和ansn有关，如果骨干节点不设置有效位的话也就和拓扑表不一样了。


现在的代码存放在OLSR_change3_4.cc中。



2017.08.27(日)

【情况一】本节点选择自己作为骨干节点：

【情况二】本节点选择邻居节点作为骨干节点：

以上两种情况如果没有设置该骨干节点的有效时长，那么都是存在问题的，因为不会定时更新。



【解决方案】
如果本节点1发送HELLO消息的时候是把自己骨干节点表中的所有节点都标志在node里面的，如果是选为MPR了，那么就标志位OLSR_MPR_NEIGH；如果是骨干节点但不是MPR节点，则标志为OLSR_CD_NEIGH；如果只是普通的对称链路节点，那么就标志为OLSR_SYM_NEIGH；
如果节点2收到其他邻居节点的HELLO消息说自己是骨干节点，那么它就通过HELLO消息告诉自己的邻居节点自己是骨干节点；
如果节点2收到其他邻居节点的HELLO消息说自己不是骨干节点，那么它就通过HELLO消息告诉自己的邻居节点自己不是骨干节点；

在节点2发送两个HELLO消息的中间，它会不断的接收到其他节点发送给它的HELLO消息.
(1)这期间只要收到一个HELLO消息说自己是骨干节点，则一直标志自己为骨干节点；
(2)如果自己选择自己作为骨干节点，则一直标志自己为骨干节点；
(3)如果全部HELLO消息都表示自己不是骨干节点，那么就通过自己产生的HELLO消息告诉邻居节点自己已经不是骨干节点了，请从那么的骨干节点表中将节点2删除。

下面来举例说明：
(1)首先节点3选择节点2作为骨干节点，并通过HELLO消息告诉节点2它为骨干节点，邻居消息2接收到消息并对自己做了标记；之后节点1没有选择节点2作为骨干节点，通过HELLO消息告诉节点2它不在自己的骨干节点表中，此时节点2不应该标志自己是普通节点，因为节点3选择自己作为骨干节点了啊；因此只要在两个HELLO消息中间接收到一个其他节点发送的HELLO消息告诉自己是骨干节点，那么就标志自己是骨关节点。
——————（问题）—————
这样就会导致在之后删除这个骨干节点的时候出现问题。到时候肯定是之前选它作为骨干节点的节点不选他，但是由于本节点的其他邻居节点都已经把它加入到骨干节点表中了，所以发送来的HELLO都标志它位骨干节点了，这样就冲突了！！！

——————（解决方法）——————
是每个节点发送的HELLO消息只是表示自己选择了哪个节点作为骨干节点，以及自己是不是骨干节点，并不需要把自己骨干节点表上所有节点都放在HELLO消息广播出去！！！

广播的时候只需要广播自己选择哪个节点作为骨干节点，并在它的link_tuple上做标记；
接收的时候只需要将接收到的骨干节点加入到骨干节点表中，不需要在它的link_tuple上做标记。

——————（问题）—————
原本是假定MPR节点一定是骨干节点，标志OLSR_MPR_NEIGH是被选为MPR节点的骨干节点；标志OLSR_CD_NEIGH的节点是没有被选为MPR节点的骨干节点；那么现在就存在问题，如果本节点选择其中一个邻居节点为骨干节点，而该节点在之后被选为MPR节点，那么它就会标志成OLSR_MPR_NEIGH而非OLSR_CD_NEIGH，如果此时有多个MPR节点，那么就不能判定当前节点选择了哪个节点作为骨干节点了。



【明天工作开始】
3602行：if ((lt == OLSR_SYM_LINK && nt == OLSR_NOT_NEIGH) ||//链路对称，但没有对称邻居

由于初始化问题，link code刚开始可能为0000，这就会出现所有节点都是CD节点的现象，要排查。




2017.08.28(一)

之前的代码在函数UCDS_CD_computation()以及UCDS_mpr_computation()中存在很多的指针问题，经过修改之后就基本都改善了，能够正常运行到最后，但是运行之后的结果还是存在问题的。运行结果存放在log170828_1中。

————————（问题）————————
在以上的日志中发现所有节点都会选择自己作为骨干节点。

————————（原因）————————
每个节点在向它的邻居节点发送的HELLO消息中加入了自己是不是骨干节点、以及自己选择的骨干节点这两个信息。在组网的最开始，本节点肯定选择自己作为骨干节点的，因为先有了邻居节点集之后才有二跳邻居节点集，所以本节点的邻居数量一定比它的邻居更多，因此每个节点都会标志自己是骨干节点。这里应该设置一个算法来消除这种错误。

————————（解决方案）————————
首先分析会出现的所有情况：
(1)如果其他节点选择本节点为骨干节点，而本节点也选择自己为骨干节点，那么只有link_tuple->local_main_node_cd() == 1，且其他邻居节点该标志位上都为0；
(2)如果其他节点选择本节点为骨干节点，而本节点选择自己的邻居节点为骨干节点，那么不仅link_tuple->local_main_node_cd() == 1，对应邻居节点的标志位上也有link_tuple->nb_main_node_cd() == 1；
(3)如果其他节点没有选择本节点为骨干节点，而本节点选择自己的邻居节点为骨干节点，那么link_tuple->local_main_node_cd() == 0，对应邻居节点的标志位上link_tuple->nb_main_node_cd() == 1。


原先自己选择了其中一个邻居节点作为骨干节点，后来更新了邻居列表之后选择了另一个邻居节点为骨干节点，那么如何把原先那个节点从骨干节点表中删除？
————在函数UCDS_CD_computation()刚开始的第四步里面有删除该节点


在日志log170828_1----3中都是错误的，其中3中揭示一个之前思考错误的问题，对于每个不同的邻居节点，他们的local_main_node_cd都是各自独立的，不是只有一个！！

在日志log170828_4中也存在错误，骨干节点的选择和更新还是有问题。

在日志log170828_5中发现一个很重要的【问题】：以节点1为例子。
节点1每收到一个HELLO消息都会马上进行处理，这个HELLO消息只能告诉节点1自己是不是骨干节点，以及自己知否选择节点1作为骨干节点。而此时如果更新其他节点是否为骨干节点的信息，那么就会在骨干节点表中将其他节点删除。log170828_5中，节点14在节点1的骨干节点表中隔一段时间出现的原因就在于此，每次的出现是因为刚接收到节点14发来的HELLO消息。
【解决方案】
把每个节点的cd标志位和节点对应起来

在日志log170828_6中，本节点选择自己作为骨干节点，在接收到其他节点的HELLO之后就会把自己从骨干节点表中删除，这应该是local_main_node_cd标志位的问题，明天自己查看！！





2017.08.29(二)
————————（）————————

————————（问题1）————————
(1)有一个节点表示自己被选为骨干节点，则本节点收到HELLO时候就会标记该节点的link_tuple->nb_main_node_cd()，并保持该标志位不变动，直到该节点不为骨干节点的时候，该标志位则会置零。
(2)如果本节点选择一个邻居节点为骨干节点，标记了link_tuple->nb_main_node_cd()，则下次没有选择该节点为骨干节点的时候，该标志位不会置零。

————————（解决方案）————————
有两种解决方案：
(1)将这两种情况下的标志位分开，即设置两个不同的标志位来标识。但是这样就会在link_tuple中再设置一项，相对而言更加麻烦；
(2)由于link_tuple->nb_main_node_cd()是int类型的，那么可以将以上的两种情况设置成不同的数值，比如1和2来区分。不过处理起来也很麻烦；
(3)将本节点选择哪个节点作为骨干节点用一个全局变量来存储，那么该全局变量每次重新选择骨干节点的时候都会被重新赋值，且不影响link_tuple中的各项。



————————（问题2）————————
现在的思路是：每个节点在HELLO消息中只说自己选择了哪个节点为骨干节点，自己或者邻居节点。选择自己是可以的，但是选择了邻居节点就没有地方存放。
(1)本节点选择了其中一个邻居节点为骨干节点，该骨干节点在之后的MPR推选中没有被选为MPR节点，那么它的neighbor_type将被标记为CD_NEIGH；收到该HELLO消息的节点就会知道自己被选为骨干节点，并对自己的HELLO消息进行标记；
(2)本节点选择了其中一个邻居节点为骨干节点，该骨干节点在之后的MPR推选中马上被选为MPR节点，那么它的neighbor_type将被标记为MPR_NEIGH；但是由于一个节点可以有好多个MPR节点，那么通过neighbor_type就不能知道在这一轮中是哪个节点被选为骨干节点。

————————（解决方案）————————
好像没有关系，是可以的。下面来捋一下整个思路：
(1)这是理想的思路，即骨干节点是可以单独读出的
节点1选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己是骨干节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2加入到骨干节点表中。

节点1后来没有选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己的不是骨干节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2从骨干节点表中移除。

(2)这是当前的情况，即骨干节点可能被标记为MPR
节点1选择节点2为骨干节点，之后还将其选为MPR，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己是MPR节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2加入到骨干节点表中，如果有可能就将节点2加入到MPR集中。

节点1后来没有选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己的不是骨干节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2从骨干节点表中移除，重新选择MPR集。


————————（成功）————————
最后的代码放在OLSR_change3_5中，运行之后的日志存放在log170829_1--2。

log170829_1中是adhoc.tcl在一定的时间将节点7从网络中删除了；
log170829_2中是adhoc.tcl恢复正常的时候运行的结果。


OLSR_change3_5中的代码在UCDS_mpr_computation()部分有太多的指针问题，感觉自己化简为繁了，对其进行修改和完善，相应的代码存放在OLSR_change3_6中，运行之后的日志存放在log170829_4---5，其中都含有路由表的拓扑结构。


在这次的修改过程中，遇到了很多的问题，也走了很多的弯路，其中关于思考的部分非常值得以后引以为鉴！！






2017.08.30(三)

昨天的代码成功可能是伪成功，只是运行的时候没有碰到下面这种情况，依旧是昨天的问题2里面有一定的思考。

————————（问题2）————————
现在的思路是：每个节点在HELLO消息中只说自己选择了哪个节点为骨干节点，自己或者邻居节点。选择自己是可以的，但是选择了邻居节点就没有地方存放。
(1)本节点选择了其中一个邻居节点为骨干节点，该骨干节点在之后的MPR推选中没有被选为MPR节点，那么它的neighbor_type将被标记为CD_NEIGH；收到该HELLO消息的节点就会知道自己被选为骨干节点，并对自己的HELLO消息进行标记；
(2)本节点选择了其中一个邻居节点为骨干节点，该骨干节点在之后的MPR推选中马上被选为MPR节点，那么它的neighbor_type将被标记为MPR_NEIGH；但是由于一个节点可以有好多个MPR节点，那么通过neighbor_type就不能知道在这一轮中是哪个节点被选为骨干节点。

————————（解决方案）————————
好像没有关系，是可以的。下面来捋一下整个思路：
(1)这是理想的思路，即骨干节点是可以单独读出的
节点1选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己是骨干节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2加入到骨干节点表中。

节点1后来没有选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己的不是骨干节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2从骨干节点表中移除。

(2)这是当前的情况，即骨干节点可能被标记为MPR
节点1选择节点2为骨干节点，之后还将其选为MPR，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己是MPR节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2加入到骨干节点表中，如果有可能就将节点2加入到MPR集中。

节点1后来没有选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己的不是骨干节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2从骨干节点表中移除，重新选择MPR集。

节点1选择节点2为骨干节点，之后还将其选为MPR，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己是MPR节点；节点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点3接收到节点2的HELLO消息，将节点2加入到骨干节点表中，并将节点2加入到MPR集中，重新发送HELLO消息；节点2接收到节点3的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己是MPR节点；点2将自己即将要发送的HELLO消息做上标志，并发送给所有的邻居节点；节点1后来没有选择节点2为骨干节点，它通过HELLO消息告诉节点2；节点2接收到节点1的HELLO消息，在邻居节点里面找到自己的节点号，从中读出自己的不是骨干节点；但是此时节点3的linkset里面节点2依旧是MPR节点，因此节点2还是认为自己是骨干节点，并广播给子的邻居节点。——————这种情况下是不能解决问题的！！！！

local_main_node_id = 1, nb_main_node_id = 2, local_main_node_cd = 0, nb_main_node_cd = 0, mine_cd_node_id = 2, mpr = 2.
local_main_node_id = 2, nb_main_node_id = 1, local_main_node_cd = 1, nb_main_node_cd = 0, mine_cd_node_id = 8, mpr = 8.
local_main_node_id = 3, nb_main_node_id = 2, local_main_node_cd = 0, nb_main_node_cd = 1, mine_cd_node_id = 8, mpr = 2.

由于每个节点发送HELLO消息都有自己的频率，是不受其他节点的影响的，所有在考虑各种情况的时候还要考虑HELLO消息定时器的问题。
 ————2：节点2接收各个节点的消息；
1————2：假设节点1发送HELLO消息，表示节点2被选为骨干节点，则节点2接收节点1的HELLO消息，并标记自己为骨干节点；
3————2：节点2此时又收到节点3的HELLO消息，表示节点2不是骨干节点；
2———— ：综合以上节点2再次发送HELLO消息的时候会表明自己是骨干节点；
2———3：此时节点3接收到节点2的HELLO消息，记录下节点2为骨干节点，之后又把节点2选为MPR节点，到达节点3的定时时间，节点3发送HELLO消息表明节点2为MPR节点；
1————2：假设节点1发送HELLO消息，表示节点2没有被选为骨干节点，则节点2接收节点1的HELLO消息，local_main_node_cd不做标记；
3————2：节点2此时又收到节点3的HELLO消息，表示节点2是节点3的MPR节点，则local_main_node_cd做上标记；
2———— ：综合以上节点2再次发送HELLO消息的时候会表明自己是骨干节点；


在log170830_4中存放的就有出现该错误，节点6一直存在于节点5\6\7\9\10\11的骨干节点表中。


----------------------------部分过程记录-------------------------

CURRENT TIME = 12.529186 , STAGE = send_pkt, node[0] send HELLO. node[0] is CD node chosen by node[0]. 

CURRENT TIME = 12.797119 , STAGE = send_pkt, node[18] send HELLO. node[0] is CD node chosen by node[18]. 

CURRENT TIME = 12.803023 , STAGE = send_pkt, node[1] send HELLO. node[0] is CD node chosen by node[1]. 

CURRENT TIME = 12.807014 , STAGE = send_pkt, node[0] send HELLO. node[0] is CD node chosen by node[0]. 

CURRENT TIME = 12.810650 , STAGE = send_pkt, node[15] send HELLO. node[0] is CD node chosen by node[15]. 

CURRENT TIME = 12.813548 , STAGE = send_pkt, node[17] send HELLO. node[0] is CD node chosen by node[17]. 

CURRENT TIME = 12.814201 , STAGE = send_pkt, node[16] send HELLO. node[0] is CD node chosen by node[16]. 

CURRENT TIME = 13.084172 , STAGE = send_pkt, node[0] send HELLO. node[0] is CD node chosen by node[0].

上面的node[0]莫名其妙就被选为骨干节点是因为mine_cd_node_id()的初始化问题，初始化的时候应该就是0，所以节点0就被选为骨干节点了。



本节点的小网络选出的骨干节点是不会在linkset上做标记的，只会将节点存放在mine_cd_node_id()里面，并加入到骨干节点表中；
linkset里面的标记都是从接收到的HELLO消息中得到的


以上的代码存放在OLSR_change3_7中



--------------------------------------以下就是新的开始---------------------------------
和雷老师讨论，最终决定从HELLO消息中预留5bit出来专门用于标注mine_cd_node_id()。

(一)首先精简HELLO消息格式
(1)msg_type可以减少一位；
(2)willingness可以缩减一位；
加上用于msg.cd_node()这一位，以及剩下空闲的两位，刚好5bit。






2017.08.31(五)

如果某个节点在选择本节点作为骨干节点，通过HELLO消息告诉本节点了，之后从网络中消失了，那么最后它的链路消息也会被删除。——————这种情况没有关系。

最后调试正确的代码存放在OLSR_change3_8.cc中，运行日志存放在log170831_2中。

--------------------------------------成功---------------------------------


【HELLO消息格式空闲bit说明】
这里面每个发送HELLO消息的源节点所对应的节点号中的4bit空间，其中最后一个bit是用于表示本节点是否是骨干节点，并将其存放在msg.hello().mine_cd_node()中。不管是自己选择自己为骨干节点，也不管是别的邻居节点选择本节点为骨干节点。
另外3bit是空闲的，之后要使用的话也是可以利用的。不过这3bit在不同节点发送的HELLO消息中是在不同的位置上的，其处理方式和上面的1bit相同。















