2017.07.15（六）
今天编程到最后出现的问题有如下：

１、代码运行到13s左右就会停止，停止的位置在"h = 1 ."里面；

２、打印出来的代码没有出现过"h = 3 ."，所以3中也是存在问题的；
怀疑3中的topology数组里面还没有存放数据，可以打印出来看看。
——当时确实还没有建立起来，里面没有参数。


其他：

查看代码运行打印出来的结果，可以看出逻辑是正确的，说明该思路是正确的。



2017.07.16（日）
１、重新看了之前代码跑出来的结果，发现在13s左右的时候，一跳路由表就基本建立成功了。
之所以会出现刚开始有的一条路由还没有加进去，是因为13s之前都是处于“发现邻居”阶段，之后才算建立成功，出来的一跳节点集结果和mac里面定义的topo数组是一致的。

２、猜测之所以在13s左右会停止出现运行错误，估计是因为我在查找一跳邻居节点的路由表循环中加入了查找两条邻居节点的路由循环，可能因为刚开始的时候，两条邻居节点集根本就没有建立起来，所以产生了冲突。
————经过验证确实如此
如果把在一跳节点集中寻找两跳节点集的循环删除，然后在"h = 2 ."里面加入这部分，就不会产生停止的现象。当时此时就会找到一条一跳的路由表项和两条两跳的路由表项，但是没关系，之后有需要的时候再优化即可。

３、"h = 3 ."部分又出现仿真停止现象。
——拓扑表中存放顺序是根据topology->last_node_id的，可见log170716_1。

４、"h = 2 ."部分又出现仿真停止现象。——OLSR_change5.cc
【原因】
——由于while()/do{}while()函数中的rtable_.lookup()是存在问题的，因为每次找到的都是同一个路由项，且该entry不符合entry->dist()==1的条件，因此运行的时候代码一直在while循环里面出不来，这是个死循环，可见log170716_７。
这是在找一跳邻居节点的二跳链路时出现的错误，之前在"h = １ ."中停止运行应该也有这方面的原因。

现在的问题是如何让它路由表项中找到跳数为1的路由项呢？
【解决方法】——待解决！！！
(1)重新写一个lookup的函数，让传参不仅为dest，还有dist；
(2)写一个for循环，遍历路由表中所有的entry，并将符合的entry找出；且需要对已经找到的entry进行标记。


【错误】——main = 12, dest = 12
……
　　　 rtable : main = 12, dest = 10, next = 11,  dist = 2, snr_min = 1.
  h = 3 .
    topology->dest_node_id = 12, topology->last_node_id = 3 . 
    topology->dest_node_id = 14, topology->last_node_id = 3 . 
    rtable1: main = 12, dest = 12, next = 3,  dist = 1, snr_min = 1.
（停止运行）
【解决】
加入判断topology->dest_node_id是否为main、nbset、nb2hopset中的节点即可——可正常运行
加入判断topology->dest_node_id是否为main、nbset中的节点——运行中断

OLSR_change6




2017.07.17（一）

１、"h = 3 ."部分出现仿真停止现象。——这是昨天遗留下来的问题
【原因】
(1)这部分里面有一个循环是for (u_int32_t h = 2; ; h++) {｝；其中h是没有上限的，所以应该是陷入了死循环;
(2)但是给h加了一个上限之后运行还是会停止，说明不止一个地方有问题;
(3)这里又陷入了一个僵局，就是在“h = 2 .”的时候搁置的问题，rtable_.lookup()函数只能找到以dest为形参的函数，而不能加入其他的限制条件；另外它只能找到第一个，不能一直找下去。——————解决方案：写一个for循环，在rtable_里面从前往后地一个个的找。

【解决】—————OLSR_change7————log170717_1(精简版在log170717_2)
写了一个rtable_.lookupall()的函数，就是遍历整个rtable的，解决了"h = 3 ."中的问题，现在也可以将它应用在"h = ２ ."中。

２、【log170717_3中是将"h = 3 ."部分原封不动，不进行修改，出来的结果也是一样的！！！！！】
在跳数为3及以上的情况，一般只需要找到一条路由项就可以了，因为最终的二跳和一跳都存在两种链路，此时可以分开成为两条。从这种角度解释确实是不需要修改"h = 3 ."的。

３、在"h = 1 ."的后面加入了一跳邻居节点的备选路由。
—————OLSR_change8




2017.07.18（二）
１、OLSR_change8中的"h = 3 ."使用的是原先的简化版本的，不是我写的，但是这样的路由表项就只有一条；虽然从上面解释的角度来说，可以通过二跳和一跳节点的多条路径来分叉，但是由于rtable中的next_node_id的限制，第一跳还是都用同一条链路的，没有做到完全的节点不相交多径的传播方式。

２、如果把"h = 3 ."部分用我自己写的替代，那么每个dest就会有两条路由表项；
这样修改了之后发现运行的时候会有一定的错误，在"h = 3 ."部分由于建立某些点的路由表项要用到其他还未建立的节点的路由表项，所以它就建立不起来，即topology->last_node_id还没有建立路由表项。具体打印出的结果可见log170718_3。
【解决】
为了解决这样的问题，就让"h = 3 ."这部分重复运行两次，这样在第一次没有加入路由表的节点可以在第二次加入，利用第一次加入的节点路由表项来加入路由表。
最后的结果可见log170718_4。
————OLSR_change9


３、【新功能】————OLSR_change10
链路的snr小到一定程度，就放弃该链路，选择跳数更长的链路来替代；其中阈值的设定通过给参数snrthreshold进行赋值来完成。




2017.07.19（三）
１、如果将节点７－８的链路断开，路由会在备选路径中通过8-9-7的链路将7加入路由表，但是根据OLSR_change10中的代码运行，目标节点为7的路由表项只有一条，因此应该在" h = 3 . "再加入一条。修改完善之后的代码存放在OLSR_change11中。

２、根据雷老师的提示，snr并不能作为判断两节点之间链路情况的好坏，因此将snr低于某值就将该链路视为断开的代码删除，得到的代码存放在OLSR_change12中。

３、原先加入一跳邻居节点的备用路由思路是不正确的，不应该在一跳节点集中找同时在二跳节点集的节点，因为这样一旦一跳节点和本节点的链路断开，那么备用路由也会消失；所以应该直接在" h = 2 ."中加入一跳邻居节点集的备用路由。（不对，还是应该放在"h=3"中）
有SNR判断以及没有SNR判断的代码分别放在OLSR_change13和OLSR_change14中。




2017.07.20（四）
















